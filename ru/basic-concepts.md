---
layout: page
title:  "Общее представление"
date: 2016-09-26 14:13:19 UTC
categories: ru
---
> Внимание, эта статья находится в процессе создания; ее содержание может (и будет) меняться пока полностью не удовлетворит автора. А до тех пор я не ручаюсь за стопроцентную достоверность приведенной информации.

В этом разделе приводятся базовые сведения о минимально нужном наборе конструкций языка. С помощью этих знаний вы сможете понимать приводимые примеры и перейти к более сложным вещам. В скобках к названию раздела указывается актуальная версия Ol.

### Основы

Ниже приводится список основных конструкций языка:

#### Комментарий (2.0)

Комментарий, это полностью игнорируемая транслятором часть текста программы, предназначенная для человека, не для компилятора.

Комментарии в Lisp бывают однострочные и многострочные. Однострочные начинаются точкой с запятой (;) и длятся до конца строки.

Многострочные начинаются диграфом #\| и заканчиваются диграфом \|#. Все, что находится между ними, полностью игнорируется лиспом.

#### Списки (2.0)

По большому счету, Lisp - это и есть списки, много списков (иногда даже очень много списков списков) плюс простое правило их обработки.

Списки являются главнейшей конструкцией Lisp. Даже аббревиатура LISP расшифровывается как "обработчик списков" (LISt Processor). Более того, сама программа, которую дают выполнить Lisp'у - тоже список. И данные, которые в конце-концов обрабатывает программа - тоже список.

Конструируются списки с помощью круглых скобок - открывающей список левой скобки "(" и закрывающей список правой ")". А так как списков в программе много, то и скобок тоже много. Их количество у некоторых может вызывать даже некое возмущение, что давным-давно вылилось в старую добрую шутку об альтернативной расшифровке акронима Lisp как "Lots of Irritating Superfluous Parentheses" (много раздражающих лишних скобок). Но к скобкам очень быстро привыкается, они легко занимают свое место в голове и при правильном форматировании исходного текста программы не только не мешают, но существенно облегчают чтение программы. Что, впрочем, относится к любому языку программирования.

Между скобками размещаются элементы списка, разделенные слева направо пробельными символами (как минимум - одним, как максимум - на ваше усмотрение). Никаких ограничений на типы элементов не накладывается: все, с чем работает лисп может быть элементом списка. Это могут быть числа, строки, другие списки. Вкладывая списки в списки, мы формируем как бы целое дерево элементов (если нарисовать списки соответственно уровню их вложенности и местом, где они должны были быть размещены - получится эдакое стилизованное перевернутое дерево). Это дерево в Lisp называется AST (АСД) - Abstract Syntax Tree (абстрактное синтаксическое дерево).

Если список отдать лиспу на выполнение, он будет его обрабатывать строго определенным образом: первый элемент списка Lisp всегда будет считать операцией - командой, которую надо выполнить над оставшейся частью списка; остальные элементы списка - аргументами этой команды. Эта логика будет применена Lisp'ом к каждому элементу, если он в свою очередь является тоже списком. И так далее рекурсивно (разбор понятия *рекурсии* тоже оставим надлежащему времени и месту) до тех пор, пока не останется необработанных списков. Этот процесс и называется процессом *вычисления* (evaluation) Lisp-программы (в терминах Lisp - EVAL).

Вот несколько примеров списков, которые можно сразу опробовать *вычислить* в терминале:

<pre><button class="doit" onclick="doit(list1.textContent)">отправить в терминал</button><code id="list1" data-language="ol">
(* 1 2 3 4 5 6 7 8 9)</code></pre>

<pre><button class="doit" onclick="doit(list2.textContent)">отправить в терминал</button><code id="list2" data-language="ol">
(print "Hello John!")</code></pre>

<pre><button class="doit" onclick="doit(list3.textContent)">отправить в терминал</button><code id="list3" data-language="ol">
(print "Ну или привет, если так понятнее.")</code></pre>

<pre><button class="doit" onclick="doit(list4.textContent)">отправить в терминал</button><code id="list4" data-language="ol">
(print "2+2 = " (+ 2 2))</code></pre>

Существует довольно небольшой список (да, снова список, и это не каламбур) базовых команд и довольно большой список построенных из них команд посложнее, которые собраны в стандарты (для Scheme - это, например, уже упомянутый во вступлении R<sup>7</sup>RS, есть и другие; Otus Lisp реализует большую часть этого стандарта и может выполнять многие программы написанные для других диалектов Lisp, следующих указанному стандарту). Стандарт будет рассмотрен в соответствующем месте, пока же стоит упомянуть только, что **print** выводит элементы списка на стандартное устройство вывода (например, в консоль), **car** возвращает первый элемент списка, **cdr** возвращает оставшуюся без первого элемента часть списка, а **\***, **+**, **-**, **/** - математические операции над элементами списка.

Странность названий car и cdr сложилась [исторически](https://en.wikipedia.org/wiki/CAR_and_CDR), их надо просто запомнить.

Пустой список создается через (list) и имеет, ввиду своего широкого использования, сразу несколько обозначений: #null, null и '(). Какое из них использовать - дело вкуса и интуиции.

Что еще можно делать со списками мы рассмотрим позже.

#### #true и #false (2.0)

В качестве первого не списка, представленного в Lisp, мы выберем пару булевых констант **#true** и **#false**. В Scheme они, как пустой список и по той же причине, имеют дополнительное альтернативное обозначение **#t** и **#f** (а также **#T** и **#F**).

Эти константы используются в условном операторе и в качестве результата предикатов.

Надо отметить, что условный оператор if работает с любыми аргументами, не только с #true и #false. При этом в качестве правды оператор if трактует все, что не является #false - таким образом #false является сильным предикатом, в отличие от своей пары #true.

Обратите внимание на такой момент, так как он довольно часто вызывает недопонимание - специальное значение #null (пустой список) не является #false! Таким образом (if #null 1 2) вернет один, а не два. Это важно, так как такое поведение характерно не для всех диалектов лиспа.

#### Числа

Следующей базовой вещью в Lisp являются числа. В отличие от большинства языков программирования, точные числа в Lisp не ограничены величиной машинного слова, но только количеством доступной программе оперативной памяти. Таким образом, в Lisp можно спокойно использовать точные числа, состоящие из сотен и тысяч знаков.

Числа подразделяются на несколько классов:

1. Класс integer чисел - это целые (Z) числа, представленные в обычном математическом виде последовательностью цифр. Как уже было указано, их размер не ограничен размером машинного слова целевой платформы и легко может превышать его. Целые числа можно вводить в виде десятичного, шестнадцатиричного, восьмиричного и двоичного числа - используя префикс #d, #x, #o и #b соответственно.
<pre><code id="Z1" data-language="ol">123456789876543212345678987654321</code><button class="doit" onclick="doit(Z1.textContent)">отправить в терминал</button></pre>
<pre><code id="Z2" data-language="ol">(* 12345678987654321 98765432123456789)</code><button class="doit" onclick="doit(Z2.textContent)">отправить в терминал</button></pre>

2. Класс rational чисел - это рациональные (Q) числа, которые представлены в виде дроби. В числителе дробь всегда содержит целое число, в знаменателе - натуральное (целое, большее нуля). Дробь рационального числа всегда является несократимой - если попытаться ввести сократимую дробь, то интерпретатор Lisp автоматически ее сократит; если возможно, то даже до целого числа. В Ol числитель рационального числа можно извлечь с помощью конструкции car, знаменатель - cdr.
<pre><code id="Q1" data-language="ol">
(print "todo: добавить пример")</code><button class="doit" onclick="doit(Q1.textContent)">отправить в терминал</button></pre>

3. Класс complex чисел - это комплексные (C) числа, которые представлены в виде A+Bi, где A и B - целые или натуральные числа, i - мнимая единица. Пробелы между частями комплексного числа не допускаются (иначе они будут проинтерпретированы как самостоятельные, раздельные элементы списка). В Ol действительную часть числа можно извлечь с помощью конструкции car, мнимую - cdr. В свою очередь, если это натуральные числа, к ним можно снова применить car и cdr.
<pre><code id="C1" data-language="ol">(* 0+3i 3-2i)  ; ==> 6+9i</code><button class="doit" onclick="doit(C1.textContent)">отправить в терминал</button></pre>

4. Класс irrational чисел - это иррациональные (I) числа, представленные в машино-зависимом (и, обычно, неточном) виде. Поэтому в Scheme они называются "неточные" (inexact). Для перевода целых чисел в иррациональные и назад существуют функции exact и inexact. А также предикаты проверки exact? и inexact?.

Для работы с числами предназначена математическая библиотека (owl math), предоставляющая большой набор математических функций, таких как +, -, *, /, modulo, gcd, min, max, quotient, floor, ceil и другие.

Более детально о внутреннем представлении чисел в Ol можно почитать в разделе о [внутреннем устройстве](?ru/internals/numbers) виртуальной машины Ol.


#### Строки

Наряду с числами Lisp умеет оперировать непосредственно текстом - строками. Строки в Ol заключаются в двойные кавычки (") и полностью поддерживают юникод.

Для работы со строками используется набор специализированных функций, таких как string-length, string-eq?, string-append, substring и других. Необходимость наличия специализированных функций обусловлена тем, что с целью обеспечения быстрой и эффективной работы внутреннее представление строк является достаточно сложным (например, в Ol при добавлении к очень длинной строке короткой, длинная не будет дублироваться, теряя ресурсы на эту операцию).

С полным набором функций работы со строками можно ознакомиться в библиотеках (owl string) и (owl unicode), а также в (r7rs core).

TBD.

#### Векторы (2.1)

Scheme поддерживает специализированную форму списка заранее заданной длины - вектор. В отличие от обычных списков некоторые операции с векторами существенно быстрее. Например, время доступа к любому элементу вектора одинаково, в то время как у списка доступ к первому элементу самый быстрый, а к последнему самый медленный. Также, есть несколько специальных конструкций языка, ведущих к более интуитивно понятному написанию программ - речь идет об использовании векторов в конструкции case.

Вектора создаются с помощью конструкции #() или (vector ...). В ol так же существует упрощающая запись [].
Более детально о векторах будет рассказано в специально отведенном для векторов разделе.


#### Символы

Лисперы очень любят символы. Это специфическое именно для лисп понятие, являющееся отдаленным аналогом переменных в других языках программирования. Однако в Lisp у символов более сложное и интересное поведение.

Начнем с того, что символы являются полностью самостоятельными элементами языка. Их можно передавать, принимать и вычислять. Причем получение значения символа происходит не во время компиляции, а во время выполнения.

Символы записываются обычной последовательностью не пробельных и не специальных знаков - букв, цифр, знаков +,-,*,?,!. Символы не могут начинаться с цифры.

Начальное значение символу присваивается с помощью директивы (define символ значение) - в терминах лисп говорят "с символом связывается значение". После чего символ можно спокойно использовать в программе.

   TBD.

#### Специальные формы

Специальными формами в Lisp называются такие конструкции языка, которые не могут быть выражены способами самого языка. Например, квотирующая форма quote.

В качестве базовых синтаксических конструкций Otus Lisp поддерживает минимально нужный набор специальных форм. Те из них, которые совпадают со специальными формами Lisp имеют соответствующее общее название. Те же, которые являются специфическими для Otus Lisp, имеют специальный префикс. Вот список этих форм.

* quote - квотирующая форма для символа, препятствует его интерпретации. Для упрощения ввода и чтения программы часто заменяется символом одинарной кавычки ('). Таким образом 'me является эквивалентом (quote me).
* lambda - объявление лямбда-функции, имеет несколько возможных вариантов объявления:
  * (lambda () <body>) - лямбда без аргументов
  * (lambda (a) <body>) - лямбда с одним аргументом
  * (lambda (a b) <body>) - лямбда с двумя аргументами
  * (lambda (a b <c d ...> <body>) - лямбда с тремя, четырьмя и т.д. аргументами)
  * (lambda args <body>) - лямбда с любым количеством аргументов, аргументы помещаются в args списком.
  * (lambda (a . x) <body>) - лямбда с одним и более аргументами, первый аргумент помещается в a, все остальные списком в x.
  * (lambda (a b . x) <body>) - лямбда с двумя и более аргументами, первый аргумент помещается в a, второй в b, все остальные списком в x.
  * (lambda (a b <c d ...> . x) <body>) - лямбда с тремя, четырьмя и т.д. и более аргументами, первый аргумент помещается в a, второй в b, третий в c, и т.д., все остальные списком в x.
* values - возвращает несколько значений одновременно
  * (let* ((a b c (values 1 2 3))) (print c b a)) => 321
* values-apply - передает несколько значений одновременно (созданных через values) в соответствующую лямбду, количество значений должно совпасть с количеством аргументов лямбды
  * (values-apply (values 1 2 3) (lambda (a b c) (print c b a))) => 321

* setq - связывание символа в текущем окружении со значением, прототип формы define
  * (setq x 12) - связывает символ x со значением 12, (print x) => 12
* letq - связывает список переменных со списком значений на время выполнения тела формы
  * (letq (a b c) (1 2 3) (print c b a)) => 321
* ifeq - "IF EQual" - оператор ветвления в смысле eq?, имеет четыре аргумента (<параметр-1> <параметр-2> <если> <иначе>), выполняет <если> в случае равенства параметров, иначе выполняет <иначе>
  * (let ((a 3) (b 4)) (ifeq a b (print "a и b равны") (print "a и b НЕ равны")))
* ifary - "IF with Arity" - оператор ветвления, имеет два аргумента, выполняет первый, если совпадает арность, иначе выполняет второй

С помощью формы ifary эффективно реализуется, например, форма case-lambda из srfi-16.

На первый взгляд, формы values-apply и bind взаимозаменяемы, однако это не так. Форма bind сначала размещает переменные в окружении, потом вычисляет значения и уже после этого связывает переменные со значениями. Что позволяет объявлять взаиморекурсивные конструкции. Форма values-apply наоборот, сначала вычисляет значения и уже потом с помощью объявления лямбды размещает переменные в окружении и связывает их со значениями.

   TBD.

#### Порты

   TBD.

#### Функции

   TBD. (а также внешние функции, результат (dload))

#### Макросы

   TBD.

   Some works more.

#### Словари (ассоциативные массивы)

Otus Lisp "из коробки" поддерживает словари - специализированный тип даных с довольно быстрыми операциями поиска и вставки значения по ключу. В качестве ключа могут быть использованы атомарные числа и символы.

   TBD.
